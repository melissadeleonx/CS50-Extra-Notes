<!DOCTYPE html>
<html>
<head>
    <title>Week 1 Shorts Lecture Notes</title>
    <link rel="stylesheet" href="cs50lectures.css"> 
</head>
<body>
<h1>Week 1 Lecture Notes: Introduction to Computer Science (CS50 Harvard)</h1>
<p><strong>Reference:</strong> Video Shorts of Dr. Doug Lloyd<br>
<strong>Goal:</strong> To turn the notes into an HTML webpage</p>
    <!-- Make a submenu anchoring the parts of the lectures -->
    <!-- Implement simple CSS code to make it more presentable -->
    <!-- Build a homepage with all the weeks as a menu -->
    <div class="my-box"> 
<h2>Data types and variables</h2>
<p>Data types and variables are unique to C.
Modern languages like PHP and JavaScript which we'll also see a little later on in the course don't actually have to specify the data type of a variable
when you use it.
You just declare it and start using it.
If it's an integer, it knows it's an integer.
If it's a character, it knows it's a character.
If it's a word, it knows it's a string, so-called.</p>

<p>In C, which is an older language, we need to specify the data type of every variable
that we create the first time that we use that variable.
So C comes with some built-in data types.</p>
    <!-- provide an image comparing C to other languages -->
<h3>Int</h3>
<p><strong><i>The first is int.</i></strong>
The int data type is used for variables that will store integer values.
So 1, 2, 3, negative 1, 2, 3, and so on.
Integers always take up four bytes of memory, which is 32 bits.
There are eight bits in a byte
Extra Notes: 1 byte = 8 bits
Characters like letters are represented using 8 bits
see ASCII(American Standard Code for Information Interchange) as reference</p>
<!-- Add url for ASCII -->
    
<p>The range of values that an integer can store
is limited by what can fit within 32 bits' worth of information.
Negative integers and positive integers, each getting half of the range.
So the range of values that we represent with an integer ranges from negative 2
to the 31st power to 2 to the 31st power minus 1
We always need a spot for 0.
And roughly here, this is about negative 2 billion to about positive 2 billion.
Give or take a couple hundred million.
So that's what you can fit in an integer variable.</p>

<h3>Unsigned integer</h3>
<p>Now <strong><i>unsigned</i></strong> ints are not a separate type of variable.
Rather, unsigned is what's called a qualifier. It modifies the data type of integer slightly.
In this case, you can also use unsigned other data types, not only integers.
What it effectively does is double the positive range of values
that an integer can take on at the expense of no longer allowing
you to take on negative values.
</p>
<p>So if you have numbers that you know will get higher than 2 billion but less
than 4 billion, for example 2 to the 32nd power.
You might want to use an unsigned int if you know your value will never be negative.
The range of values that you can represent with an unsigned integer
as to a regular integer,
are 0 to 2 to the 32nd power minus 1, or approximately 0 to 4 billion.
So you've effectively doubled the positive range that you can fit,
but you've given up all the negative values.</p>
<p>Unsigned is not the only <strong><i>qualifier</i></strong> that we might see for variable data types.
There are also things called <i>short and long and const</i>.
These topics will be discussed later in the course</p>

<h3>Chars</h3>
<p>So chars are used for variables that will store single characters.
<strong><i>Char</i></strong> is short for character.
And sometimes you might hear people pronounce it as <i>car</i>.</p>
Characters always take up one byte of memory, which is just 8 bits.
This means that they can only fit values in the range of negative 2
to the seventh power,
or negative 128, to 2 to the 7th power minus 1, or 127.</p>
    
<p>
    Thanks to <strong>ASCII</strong>, it was long ago decided a way to map those positive numbers
    from 0 to 127 to various characters that all exist on our keyboard.
    So as we'll see later on in the course, probably come to memorize at some point,
    capital A, maps to the number 65
    And the reason for that is because that's what it's been assigned by the ASCII standard.
    Lowercase A is 97.
    The character 0 for when you actually type the character, not
    representing the number zero, is 48.</p>

<h3>Floating point numbers</h3>
<p><strong><i>Floating point numbers</i></strong>are also known as real numbers.
    They're basically numbers that have a <strong><i>decimal point</i></strong> in them.
    Floating point values like integers are also contained within 4 bytes of memory.
    There's no number line because describing the range of a float isn't exactly clear or intuitive.</p>

<p>
    Suffice it to say you have 32 bits to work with.
    And if you have a number like pi, which has an integer part 3, 
    and a floating point part, or decimal part 0.14159, and so on, 
    you need to be able to represent all of it-the integer part and the decimal part.</p>

<p><i>One thing is that if the decimal part gets longer and longer,
if I have a very large integer part,
I might notbe able to be as precise with the decimal part.
And that's really the limitation of a float. Floats have a precision problem.</i></p>

<p>
    We only have 32 bits to work with, so we can only be so precise with our decimal part.
    We can't necessarily have a decimal part precise to 100 or 200 digits,
    because we only have 32 bits to work with. So that's a limitation of a float.
    Now fortunately there's another data type called double, which somewhat deals with this problem.
</p>

<h3>Doubles</h3>
<p><strong><i>Doubles</i></strong>, like floats, are also used to store real numbers, or floating point
    values.
    The difference is that doubles are double precision.
    They can fit 64 bits of data, or eight bytes.
    It means we can be a lot more precise with the decimal point.
    <!-- Cite the pi formula with illustration. Instead of having pi to seven places maybe, with a float,
    we can maybe have it to 30 places.-->
    If that's important, you might want to use a double instead of a float.
    If you're working on a long decimal place and a lot of precision is important
    you probably want to use a double overfloat.
    Now for most of your work in CS50, a float should suffice.
    But do know that doubles exist as a way to somewhat deal with the precision
    problem by giving you an extra 32 bits to work with for your numbers.
</p>
<h3><i>Void</i>(Not a Datatype, only a Type)</h3>
<p><strong><i>Void is a type.</i></strong> It does exist. But it is not a data type.
    We can't create a variable of type void and assign a value to it.
    But <strong><i>functions</i></strong>(which will be discussed on Week 2), for example, can have a void return type.<br>
    If you see a function that has a void return type,
    it means it doesn't return a value.
    <!--Insert an image of the common function that we've used so far in CS50 that doesn't return a value?-->
    <h4>Examples of common Functions that does not return a value</h4>
    <ul>
        <li><strong>Printf:</strong> It does not actually return anything to you.
            It prints something to the screen,a side effect of what printf does.
            But it doesn't give you a value back. You don't capture the result
            and store it in some variable to use it later on.
            It just prints something to the screen and you're done.
            So we say that printf is a void function. It returns nothing. </li>
        <li><strong>Perimeter list of a function(<i>Int main (void)</i>):</strong>
            Does that ring a bell? Basically what that means is that main doesn't take any parameters.
            There's no argument that get passed into main.
            Now later on we'll see that there is a way to pass arguments into main,
            but so far what we've seen is int main void.<br>
            Main just doesn't take any arguments. And so we specify that by saying void.
            We're just being very explicit about the fact that it doesn't take any arguments.
            So for now, suffice it to say that void basically should just serve as a placeholder for you as thinking about as nothing.
            It's not really doing anything.
            There's no return value here.
            There's no parameters here.
            It's void.<br>
            It's a little more complex than that.
            But this should suffice for the better part of the course.
            And hopefully now you have a little bit more of a concept of what void is.</li>
        <li><strong>New functions you create:</strong> Throughout the course, we will implementing our own functions to support our coded programs</li>
    </ul> 
    </p>
    <p><p class="centered-paragraph"><i>So those are the five data types you'll encounter that are built-in to C. But in CS50, we also have a library.
        The <strong>CS50.h</strong>, which you can include on your code and which will provide you with two additional types
        that you'll probably be able to use on your assignments, or just working generally in programming.
    </i>
    </p>
<h3>Bool or Boolean data type</h3>
<p>
    The first of these is <strong><i>bool</i></strong>. It is used for variables that will store a Boolean value.
    If you've ever heard this term before, you might know that a Boolean value is capable of only
    holding two different distinct values. <strong>True</strong> and <strong>False</strong><br>
    Now this seems pretty fundamental, right? It's kind of a surprise that this doesn't exist in C as it's built-in.
    And in many modern languages, of course, Booleans are a standard default data type. But in C, they're actually not. But we've created it for you. So if you ever need to create a variable whose type is bool,
    just be sure to #include CS50.h at the beginning of your program,
    and you'll be able to create variables of the bool type.
</p>
<h3>String</h3>
<p>
    The other major data type that we provide for you in the CS50 library is <strong><i>string</i></strong>. So what is a string?<br>
    Strings are really just words. They're collections of characters. They're words. They're sentences. They're paragraphs.
    Might be whole books, even. Very short to very long series of characters.<br>
    If you need to use strings, for example, to store a word, just be sure to include CS50.h at the beginning of your program
    so you can use the string type. And then you can create variables whose data type is string.</p>
    <p>Now later on in the course, we'll also see that that's not the entire story, either.
    We'll encounter things called <strong><i>structures</i></strong>,
    which allow you to group what may be an integer and a string into one unit.
    And we can use that for some purpose, which might come in handy later on in the course.
</p>
<p>
    And we'll also learn about defined types, which allow you to <strong>create your own data types</strong>. We don't need to worry about that for now.
    But just know that that's something on the horizon, that there's a lot more to this whole type thing than I'm telling you just
    now.
</p>
<h2>Variables</h2>
<p>
    So now that we've learned a little bit about the basic data types and the CS50 data types, let's talk about how to work with variables and create them using these data types in our programs.
    If you want to create a variable, all you need to do is two things. 
</p>
<!--Insert an image of the things we need to do to create a variable-->
<p>
    First, you need to give it a type.<br>
    The second thing you need to do is give it a name.<br>
    Once you've done that and slapped a semicolon at the end of that line,
    you've created a variable.<br>
    For examples: <strong>Int number; char letter;</strong><br>
    What have I done here? I've created two variables.<br>
    The first, the variable's name is number. And number is capable of holding integer type values, because its type is int.<br>
    Letter is another variable that can hold characters because its data type is char.
</p>
<p>If you find yourself in a situation where you need to create multiple variables of the same type,
    you only need to specify the type name once. Then just list as many variables of that type as you need.<br>
    For example:<br>
    Int height; new line.<br>
    Int width;<br>
    And that would work too. I'd still get two variables called height and width, each of which
    is an integer. But I'm allowed to, things to C syntax, consolidate it into a single line.
    Int height, width; It's the same thing.<br>
    I've created two variables, one called height one called width, both of which
    are capable of holding integer type values.
</p>
<p>
    Similarly here, I can create three floating point values at once.
    For examples: float squareRoot2, squareRoot3, pi;<br>
    We can also do this on three separate lines and that would work too.<br>
    float squareRoot2;<br>
    float squareRoot3;<br>
    float pi;<br>
    We can consolidate this into a single line of code. Makes things a little bit shorter, not as clunky.</p>
<p> Now in general, it's good design to only declare a variable when you need it.
    And we'll talk a little bit more about that
    later on in the course when we discuss <strong><i>scope</i></strong>.
    So we don't necessarily need to create all of our variables
    at the beginning of the program, which some people might have done the past,
    or was certainly a very common coding practice many years ago
    when working with C. You might just want to create a variable right when
    you need it.</p>
<p>So we've created variables. How do we use them? After we declare a variable, we don't need
    to specify the data type of that variable anymore. In fact, if you do so, you might end up with some weird consequences
    that we'll kind of gloss over for now. But suffice it to say, weird things are going
    to start happening if you inadvertently re-declare variables with the same name
    over and over.</p>

<p>So here I have four lines of code. And I have a couple of comments there just indicating what's happening on each line just to help
you get situated in what's going on. So the example previously,<strong>int number</strong>; is a <strong>variable declaration.</strong>
I've now created a variable called number that's capable of holding integer-type values. I've declared it.<br>
int number;<br>
number = 17; <br>
The next line I'm assigning a value to number. Number equals 17. What's happening there?<br>
I'm putting the number 17 inside of that variable. So if I ever then print out what the contents of number are later on,
they'll tell me it's 17.<br>
int number; (That's a declaration)<br>
number = 17; (That's an assignment)<br>
printf("%i", number);<br>
So I've declared a variable, and then I've assigned it. We can repeat the process again with char letter;.</p>

<p>
    Now this process might seem kind of silly. Why are we doing this in two lines of code?
    Is there a better way to do it? In fact, there is.<br>
    Sometimes you might see this called <strong>initialization</strong>. It's when you declare a variable and assign a value at the same time.
    This is actually a pretty common thing to do. When you create a variable, you usually want it to have some basic value. Even if it's 0 or something.
    You just you give it a value. You can initialize a variable.</p>
    <p>
    Int number equals 17 is the same as the first two lines of code up above.<br>
    Char letter equals h is the same as the third and fourth lines of code above.<br>
    The most important takeaway here when we're declaring and assigning
    variables is after we've declared it, notice I'm not using the data type again.
    I'm not saying int number equals 17 on the second line of code, for example.
    I'm just saying number equals 17.</p>
    <p>
    Again , re-declaring a variable after you've already declared it can lead
    to some weird consequence.</p>
<h2>Operators</h2>
<p>
<!-- 
>>let's talk about operators in C.
So, we've already seen one, in fact, equals the assignment operator.
It allows us to just put a value into a variable.
That's the assignment operator, single equal sign.
In order to manipulate and work with values and variables in C,
we have a number of operators at our disposal that we can use.
Let's take a look at some of the common ones
starting with arithmetic operators.
As you might expect, we can do pretty basic math operations in C.
We can add, subtract, multiply, and divide numbers using plus, minus, star,
and slash, respectively.
Here's a couple of lines of code in which we do that.
So, we have int x equals y plus 1.
Let's assume that somewhere up above this line of code
we had said int y equals 10.
What's the value of x after I execute this first line of code?
Did you say 11?
You'd right.
Why is that?
Well, y was 10.
Some I'm saying int x equals 10 plus 1.
10 plus 1 is 11.
So, the value 11 gets stored in the variable x.
Not too bad, right?
>> How about this next line of code? x equals x times 5.
Well, before we executed this line of code, x was 11.
So, what is the value of x after this line of code?
Take a second.
So, x equals x times 5.
x was 11.
So, x equals 11 times 5.
Or 55.
So if you said 55, you'd be right.
>> Now, it may be a little confusing, but with the way that assignment works in C
is the value on the right gets assigned to the value on the left.
So, first we evaluate x times 5.
So, 11 times 5 is 55.
And then we store that value in x.
The 11 that was there before is now overwritten.
So x's value is now 55.
Hopefully that's fairly straightforward.
>> There's another operator that you've probably not necessarily heard
called this, but you've certainly worked with in the past
if you remember your days of long division way back in grade school.
It's called the modulus operator.
What modulus does is it gives you the remainder
when you divide two numbers together.
So, if I say 13 divided by 4, what's the remainder?
And that value would be calculated by the modulus operator.
>> So, I have a line of code here, int m equals 13 mod 4.
And I say here in a comment that m's value is now 1.
Why do I say that?
Well, do the long division out in your head, if you bear with me for a second.
So, I have 4 divided by 13.
4 goes into 13 three times with a remainder of 1.
So, basically, all the modulus operator does
is it tells you when you divide, you get the remainder.
You might think that's actually not a terribly useful thing,
but you'd be surprised, actually, by how frequently that modulus
operator can come in handy.
>> There's a couple of problems we'll do CS50 that deal with it.
It's also good for doing things like random number.
So, for example if you've ever heard of a random number generator,
that's going to give you a number from 0 to some huge number.
But maybe you only really need a number from 0 to 20.
If you use the modulus operator on that giant number that
gets generated by the random number generator,
you're going to take whatever huge value it is, divide it by 20,
and get the remainder.
The remainder can only be a value from 0 to 19.
So, you use modulus operator to take this huge number
and whittle it down into something a little more meaningful.
I'm pretty sure you'll be able to use both of those
at some point in the future in CS50.
>> So, C also gives us a way to apply an arithmetic
operator to a single variable in a little more shorthand way.
So, in the previous slide, we saw x equals x times 5.
That worked.
x times 5 then gets stored back in x.
There's a shorter way to do it, thought, and it's the syntax x times equals 5.
It's the same exact thing as saying x equals x times 5.
It's just a slightly shorter way to do it.
And when you see some distribution code or you
see some sample code that does things like this,
just be familiar with what the syntax means.
You certainly don't have to use it, but if you do,
it might make your code look a little slicker.
And know that you can also use any of the different operators we've already
seen before instead of times.
You could say x plus equals 5, minus equals 5, times, divide, and mod.
All of those work.
>> There's also something that's so common in C
that we've decided to refine that even further.
Incrementing a variable by 1 or decrementing a variable by 1
is such a common thing-- especially when we talk about loops a little later
on-- that we've decided instead of saying something like x plus equals 1,
or x equals x plus 1, we've even short handed that to x plus plus.
So, x equals x plus 1, x plus equals 1, and x plus plus all do the same thing.
They all increment x by 1.
But that incrementing and decrementing by 1
is so common that we have plus plus and minus minus
that allow us to shorthand that even further.
>> So, let's switch gears for second and talk about Boolean expressions.
All which are also kind of fall into the overall category of operators.
But Boolean expressions, unlike arithmetic operators,
are used for comparing values.
So, again, all Boolean expressions in C evaluate to one of two possible values,
recall.
True or false.
That's the only two values that Boolean variable can take on.
We can use the results of a Boolean expression
in a lot of ways in programming.
In fact, you'll be doing this quite a lot.
>> For example, we might decide, well, if some condition is true,
maybe I'll take this branch down my code.
A conditional, so to speak.
We'll learn about those soon too.
Or maybe, as long as this is true, I want
to keep doing this over and over and over.
A loop.
In both cases, know that we're using a Boolean expression, a true or false,
to decide whether or not to take a particular path.
Sometimes when we're working with Boolean expressions,
we will use variables of type Bool.
You might have declared a Bool typed variable,
and you'll use in your Boolean expression.
But you don't always have to do.
As it turns out, in C, every non-0 value is the same as saying true.
If you had declared a variable of type Boolean,
and assigned it the value true, that's the same as declaring an integer
and assigning it the value 1, 2, 3, or really any value
whatsoever other than 0.
Because in C, every non-0 value is true.
0, on the other hand, is false.
This might come in handy later on to know,
but just something to keep in mind.
We don't always have to use Boolean type variables when we
are working with Boolean expressions.
>> There are two main types of Boolean expressions that we'll work with.
Logical operators and relational operators.
The language there is not terribly important.
It's really just how I'm grouping them.
And you'll certainly, I think, quickly realize what a relational operator is,
based on what they are when we talk about them in a second.
But don't worry about necessarily memorizing the term logical operator
or relational operator.
I'm just using it to group them in a logical way.
>> So, let's take a look at the three logical operators
that we'll see quite a bit in programming in CS50
and in programming more generally.
Logical AND is true, if and only if both operands are true.
Otherwise false.
Where does that mean?
So, let's say that I am at a point in my code where I have
two variables, x and y.
And I want to decide whether to do something in my code
based on if x is true and y is true.
I only want to do it if both of them are true,
otherwise I don't want to go down that path because it's not going to help me.
What I can say is if x & & y.
That will be a logical Boolean expression comparing x and y
and taking a certain path based on what their values are.
So, if x is true and y is true based on this truth table here,
only then will we go down that path.
If x, & & y.
It's only true-- the and is only true if x is true and y is true.
If either one is false, as we see the truth table,
then both x and y are not true.
And so, x & & y is false.
>> Logical OR is true if and only if at least one operand is true.
Otherwise false.
So logical AND required both x and y to be true.
Logical OR requires x to be true or y to be true or both x and y to be true.
So, again, we kind of find ourselves in a situation
where we're going to our code, and we reached a fork in the road.
And we want to go down a particular path if x is true
or y is true, but not necessarily if both are true.
But possibly if both are true.
So if x is true and y is true, we'll go down that path.
x is true.
One of them is true, right?
If x is true and y is true.
If x is true, and y is false, one of them is still true.
So, x or y is still true.
If x is false, and y is true, one of them is still true, right?
y is true, in this case.
So, it's true that x or y is true.
Only if x is false and y is false do we not go down that path,
because neither x nor y is true.
Now, if you're looking at the screen right now
and wondering what that symbol is for logical OR,
it's called the vertical bar.
And if you looking at your keyboard for a minute, as I'm doing now,
it's usually just above the Enter key, on most keyboards,
on the same key as the backslash.
It's also usually right next to the square brackets.
So, it might be a key that you haven't typed very much in the past.
But, if you're ever doing logical comparisons,
as we'll be doing a lot in the course, it's
going to be useful to find that key and use it.
So, it's usually on the same key as backslash just above Enter.
>> The final logical operator is NOT.
And NOT's pretty straightforward.
It inverts the value of its operand.
If x is true, then not x is false.
If x is false, then not x is true.
Sometimes you'll hear this symbol pronounced as bang or exclamation
or not.
It's pretty much all the same thing.
In case you hear that spoken and you're not sure what that means,
it's just the exclamation point, but sometimes it's
called a couple different things.
All right, so that takes care of logical operators.
So, let's talk about relational operators.
Again, if you're familiar with this arithmetic back in grade school,
you're probably familiar with how these work already.
These behave exactly as you'd expect.
So less than it's true, in this example, if x is less than y.
So, if x is 4 and y is 6, x is less than y.
That's true.
Less than or equal to works pretty similarly.
If x is 4, and y is 4, then x is less than or equal to y.
Greater than. x is greater than y.
And greater than or equal to, x is greater than or equal to y.
If it's true, then you'll pass that expression,
and you'll go down that path on the road.
If you have an if x is greater than y, and x is, in fact, is greater than y,
you'll do whatever is subject to that condition.
>> Notice that we don't have a single character for less than
or equal to, as you might be familiar with from math textbooks.
So, we have the less than symbol, followed by an equal sign.
That's how we represent less than or equal to.
And similarly, do we do that for greater than or equal to.
>> The final two relational operators that are important
are testing for equality and inequality.
So, if x equals equals y, is true if x and y's value is the same.
If x is 10, and y is 10, then x equals equals y is true.
If x is 10 and y is 11, x equals equals y is not true.
We can also test for inequality using exclamation point or bang or NOT,
again.
If x is not equal to y, if that's the test we're using here,
we'd be good to go.
So, if x is not equal to y, we'll go down that path.
>> Be really careful here.
It's a really common mistake-- and one I certainly made quite a lot when
I was getting started-- to accidentally mistake
the assignment operator, single equals, for the equality comparison operator,
double equals.
It'll lead to some weird behavior in your code,
and usually the compiler will warn you about it when you try
and compile your code, but sometimes you might be able to sneak it by.
It's not necessarily a good thing that you sneak it by, though.
Just so if you are doing an inequality test,
if you're checking whether two different variables have the same value
inside of them, make sure to use equals equals, and not single equals.
And that way your program will have the behavior you intend.
.-->

</p>
<h2>Conditional Statements</h2>

</div>   
<!-- Add a superscript reference to the footnote -->
p>The following content is adapted from Harvard CS50 Lecture and Video Shorts and is licensed under <a href="#footnote1">CC BY-NC-SA 4.0</a>.</p>

    <!-- Create a footer for the footnote -->
    <footer>
        <hr>
        <p id="footnote1"><sup>1</sup> Portions of this content have been adapted from Harvard CS50 Lecture and are licensed under the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)</a> license. For more details and specific attribution requirements, please refer to the original Harvard CS50 Lecture source.</p>
    </footer>
</body>
</html>


<!--So now let's talk about something really useful in programming--
conditional statements.
So conditional expressions allow your programs
to make decisions and take different forks in the road, something
I alluded to little earlier, depending on the values of variables,
or based on what the user inputs at the programmer, at the command line,
or if you have a prompt or something like that.
C has a couple of different ways to express conditional expressions, which
we also sometimes will call a conditional branch in your programs.
And some of these are going to look pretty familiar to you from scratch,
so we'll even pull them up side by side, just
you can make that analogy in your head.
>> So, if-- if is a pretty simple conditional.
If you recall from scratch on the right here
you could fill in that is hexagon with a blue expression if mouse down
or if x is less than 10, or something like that.
And then, if x was less than 10, or if the mouse was in fact, down,
all of the code inside of the puzzle piece would execute.
All the things that fit inside that C shape.
>> Similarly, do we have if on the left there.
If Boolean expression, which I'm just using
as a substitute for one of the Boolean expressions we previously discussed,
open curly brace, close curly brace.
So think of open curly brace and closed curly brace
as sort of analogous to the sandwich effect of the if block on the right
from scratch.
>> If the Boolean expression in the if statement is true,
then all the lines of code between the curly braces
will execute in order from top to bottom.
If the Boolean expression is false, we'll
skip over everything in between the curly braces, because we only
want to go down that fork in the road if the Boolean expression is true.
>> We can take this one step further with if else.
So this Scratch block is pretty similar to the one
we saw just a second ago, except it takes two different paths based
on what happens.
So if the mouse was down, or if x was less than 10,
we'll do everything that's in between that first fork, that first C. ,
>> Otherwise, if the mouse is up, or x is not less than 10,
we will do everything in the second set.
And that's analogous to what you see here for C. If Boolean expression,
do the stuff between the first set of curly braces.
Else, do the stuff between the second set of curly braces.
So if the Boolean expression is true, we'll
do whatever's between the first set.
If the Boolean expression is false, that would trigger the else,
and we would do whatever's in the second set of curly braces.
Again, top to bottom, all lines in between the braces.
>> In C, it's possible to create an if-else if-else chain.
In fact you can have if-else if-else if-else, if, and so on and so on and so
on.
In Scratch, this required nesting the blocks.
You add an if-else, and you had to put another one inside of the else,
and so on, and it got kind of nested and complicated.
But C, we don't have to do that.
We can actually just have it be a chain like this.
Again, as you might expect, all of these branches are mutually exclusive.
You can only ever go down one of the branch.
If this is true.
Otherwise, if this is true.
Otherwise, if this is true.
Otherwise, do this.
So all four of the branches in this example are mutually exclusive.
It's an if-else if-else chain.
>> It is possible though, and sometimes very useful,
to create a chain of not mutually exclusive branches.
In this example, only the third and fourth branches are mutually exclusive.
It could be that you could satisfy the first condition,
and you could satisfy the second condition,
and you could satisfy the third condition-- in which case
you would go down the first branch, then you go down a second branch,
then you would go down the third branch.
Or perhaps you satisfy the first condition, and the second condition,
but you don't satisfy the third condition.
In this case you go down the first branch and the second branch,
and then the fourth branch,
>> The reason for this is that the else will only bind to the nearest if.
So even though there's an else here, that
doesn't necessarily create a mutually exclusive chain of everything.
It's only the expression there with Boolean
expression 3-- that's the mutually exclusive with the else.
So it is possible, and sometimes quite useful,
as I said, to create a chain of not mutually exclusive branches.
Let's take a look at a different kind of conditional, which
you have not seen before in Scratch.
There's something called the switch statement.
The switch statement is kind of neat because it's
a conditional statement that allows you to specify distinct cases,
instead of relying on Boolean expressions to make decisions for you.
So for example, let's say that I have this program,
and I'm asking the user to provide input to me.
So I say, int x = Get Int(), and if you're not familiar yet,
get int is a function that is also included in the CS50 library,
so if you #include CS50.H you'll have access to Get Int() and all of its
cousins-- GetFloat, GetString, and so on.
Basically one Get function for every data type that we've already discussed.
>> So Int x equals GetInt.
Basically what's happening is I'm at the terminal.
I'm asking the user to type in a number.
>> And here I'm switching what I'm doing, depending
on what the user typed at the prompt.
So if they typed one, I print out one.
And then I break.
If they type two, I print out two.
And then I break.
It's important to break between each case
because otherwise you will fall through.
So if I didn't have any breaks there, and the user
typed one, what would happen is it would print one, two, three, sorry.
That's kind of strange behavior, right?
You might think so.
But there are actually some cases where this could be a pretty useful thing.
So here's another example of a switch statement where I omit the breaks.
But I do it on purpose.
>> So what happens here?
Think for a second.
You may even want to pause the video.
>> What happens here if the user types four?
So I've asked the user for input.
And they provide the value 4.
What gets printed when I do that?
On the previous slide, there were breaks between all the cases.
And so it would just print four and then stop.
But in this case, it won't.
What will happen is you will fall through each case.
>> So in this case I've organized my cases in such a way that if the user types 4,
I will print four, three, two, one, blast off.
And if they typed 5, I would start at five and do the same thing.
If they typed 1, I would just do one, blast off.
>> So in this case, I'm using a switch kind of cleverly so
that I do intend to fall through all the cases.
But generally you're probably gonna want to break between all of them,
unless you have a situation like this one where you're
kind of leveraging the fact that you'll fall through the cases without a break.
So that's the second of the major types of conditional statements.
The last of which is ?: So I have two snippets of C code here.
One on the left and one on the right.
The one on the left should probably be pretty familiar to you.
>> I have Int x.
And I probably should have asked the user
for-- this should probably be Int x equals GetInt, or something like that.
And then I'm making a decision.
If some Boolean expression is true, assign x the value 5.
Otherwise, assign x the value 6.
>> That on the left should probably be pretty familiar from our discussion
of If Else just a moment ago.
Would you be surprised to know that the line on the right
does the exact same thing?
>> So this is called ?: or sometimes called the ternary operator.
And it's pretty cool.
It's usually used as a cute trick.
>> But what it allows you to do is to simulate an If Else with really small,
really trivially short conditional branches.
You generally wouldn't use ?: if you had six lines of code between each set
of curly braces.
But if you're just making a quick decision,
if you're going to do one thing or the other and it's very simple,
this might be an example of how to do it with ?: the ternary operator.
So Int x equals expression ?
The thing after the question mark is what x's value
will be if expression is true.
>> The thing after the colon is what x's value
would be if the expression was false.
So I'm asking myself, is the expression true?
If it is, assign x the value 5.
If it's not, assign x the value 6.
Again, like I said.
This is usually just a cute trick.
And sometimes if you become really comfortable with it,
you'll do this because it looks kind of cool in your programs.
Generally I'm presenting it to you now so you're familiar with it
if you see it.
But certainly know you don't have to write it in any of your code.
But it is something to be familiar with, because you'll definitely encounter
snippets of code here and there where this ?: syntax,
AKA the ternary operator, is used.
>> So quick summary on what conditionals are,
and what the options are available to you in C. You have If and if-else,
and if else if, et cetera.
You can use Boolean expressions for those to make decisions.
>> With switch statements you use discrete cases to make decisions.
You would specifically say, if it's one, or if it's two, or if it's three,
I'll do this thing, or this thing, or this thing.
And ?: can to be used to replace very simple if-else branches,
or if-else chains to make your code look a little fancy.-->
